<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Modern editing needs | Arian's blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Times have changed. The boomer-coded text editor definition of a grid
of bytes is just not enough. Code has structure, tooling, footguns
(especially when it&rsquo;s a dynamically typed language), and many other
attributes that shouldn&rsquo;t be edited by typing vi code.py into a
console and expecting things to be done in a timely manner while not
making mistakes. It simply is not possible by a bad developer like me.
A zoomer perspective of the past
When I started to seriously code, I was already in college and LSPs
were a thing. While IDEs are things I&rsquo;m familiar with and use, LSPs
bridge 90% of the gap. From what I&rsquo;ve read on the interwebs, the
IDE-only era was grim, and text editors that had genuine advantages
(Emacs for extensibility and Vim for efficient editing) had their own
matrix of extensions that provided a subpar experience. There were
hacks for IDE-like features like ghcide, but they were never
sufficient, and those hacks were for corpowagies (who didn&rsquo;t write
Haskell)."><meta name=generator content="Hugo 0.150.1"><meta name=robots content="index, follow"><link rel=stylesheet href=/blog/ananke/css/main.min.2438bcafd7af9675c426d1a4afcd16cfff18e4e10f401071e45b5ccd3be40a0d.css><link rel=canonical href=http://arian-d.github.io/blog/posts/modern-editing-needs/><meta property="og:url" content="http://arian-d.github.io/blog/posts/modern-editing-needs/"><meta property="og:site_name" content="Arian's blog"><meta property="og:title" content="Modern editing needs"><meta property="og:description" content="Times have changed. The boomer-coded text editor definition of a grid of bytes is just not enough. Code has structure, tooling, footguns (especially when it’s a dynamically typed language), and many other attributes that shouldn’t be edited by typing vi code.py into a console and expecting things to be done in a timely manner while not making mistakes. It simply is not possible by a bad developer like me.
A zoomer perspective of the past When I started to seriously code, I was already in college and LSPs were a thing. While IDEs are things I’m familiar with and use, LSPs bridge 90% of the gap. From what I’ve read on the interwebs, the IDE-only era was grim, and text editors that had genuine advantages (Emacs for extensibility and Vim for efficient editing) had their own matrix of extensions that provided a subpar experience. There were hacks for IDE-like features like ghcide, but they were never sufficient, and those hacks were for corpowagies (who didn’t write Haskell)."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-16T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-16T00:00:00+00:00"><meta property="article:tag" content="Editors"><meta property="article:tag" content="Emacs"><meta property="article:tag" content="Helix"><meta property="article:tag" content="Opinion"><meta property="article:tag" content="Rant"><meta itemprop=name content="Modern editing needs"><meta itemprop=description content="Times have changed. The boomer-coded text editor definition of a grid of bytes is just not enough. Code has structure, tooling, footguns (especially when it’s a dynamically typed language), and many other attributes that shouldn’t be edited by typing vi code.py into a console and expecting things to be done in a timely manner while not making mistakes. It simply is not possible by a bad developer like me.
A zoomer perspective of the past When I started to seriously code, I was already in college and LSPs were a thing. While IDEs are things I’m familiar with and use, LSPs bridge 90% of the gap. From what I’ve read on the interwebs, the IDE-only era was grim, and text editors that had genuine advantages (Emacs for extensibility and Vim for efficient editing) had their own matrix of extensions that provided a subpar experience. There were hacks for IDE-like features like ghcide, but they were never sufficient, and those hacks were for corpowagies (who didn’t write Haskell)."><meta itemprop=datePublished content="2025-09-16T00:00:00+00:00"><meta itemprop=dateModified content="2025-09-16T00:00:00+00:00"><meta itemprop=wordCount content="1257"><meta itemprop=keywords content="Editors,Emacs,Helix,Opinion,Rant"><meta name=twitter:card content="summary"><meta name=twitter:title content="Modern editing needs"><meta name=twitter:description content="Times have changed. The boomer-coded text editor definition of a grid of bytes is just not enough. Code has structure, tooling, footguns (especially when it’s a dynamically typed language), and many other attributes that shouldn’t be edited by typing vi code.py into a console and expecting things to be done in a timely manner while not making mistakes. It simply is not possible by a bad developer like me.
A zoomer perspective of the past When I started to seriously code, I was already in college and LSPs were a thing. While IDEs are things I’m familiar with and use, LSPs bridge 90% of the gap. From what I’ve read on the interwebs, the IDE-only era was grim, and text editors that had genuine advantages (Emacs for extensibility and Vim for efficient editing) had their own matrix of extensions that provided a subpar experience. There were hacks for IDE-like features like ghcide, but they were never sufficient, and those hacks were for corpowagies (who didn’t write Haskell)."></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/blog/ class="f3 fw2 hover-white no-underline white-90 dib">Arian's blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Modern editing needs</h1><time class="f6 mv4 dib tracked" datetime=2025-09-16T00:00:00Z>September 16, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Times have changed. The boomer-coded text editor definition of a grid
of bytes is just not enough. Code has structure, tooling, footguns
(especially when it&rsquo;s a dynamically typed language), and many other
attributes that shouldn&rsquo;t be edited by typing <code>vi code.py</code> into a
console and expecting things to be done in a timely manner while not
making mistakes. It simply is not possible by a bad developer like me.</p><h2 id=a-zoomer-perspective-of-the-past>A zoomer perspective of the past</h2><p>When I started to <em>seriously</em> code, I was already in college and LSPs
were a thing. While IDEs are things I&rsquo;m familiar with and use, LSPs
bridge 90% of the gap. From what I&rsquo;ve read on the interwebs, the
IDE-only era was grim, and text editors that had genuine advantages
(Emacs for extensibility and Vim for efficient editing) had their own
matrix of extensions that provided a subpar experience. There were
hacks for IDE-like features like <a href=https://github.com/haskell/ghcide>ghcide</a>, but they were never
sufficient, and those hacks were for <a href=https://knowyourmeme.com/memes/wagie>corpowagie</a>s (who didn&rsquo;t write
Haskell).</p><p>Syntax highlighting was difficult. Every editor ha(d|s) their own
custom parsing engine for each language with its custom rules and
custom errors. If you like Emacs, Lisp, parsing, or C-like languages,
I&rsquo;d very much implore you to read <a href=https://cgit.git.savannah.gnu.org/cgit/emacs.git/tree/lisp/progmodes/cc-engine.el>cc-engine.el</a>. It is a feat of
engineering spanning 4 decades with contributions from people around
the globe. It&rsquo;s close to 16k lines at the time I&rsquo;m writing this, and
it&rsquo;s actively being worked on. While it&rsquo;s a much more impressive
engine than <a href=https://github.com/vim/vim/blob/master/runtime/syntax/c.vim>Vim&rsquo;s hacky c.vim</a>, it&rsquo;s not bug free.</p><p>Tooling was bad. Debugging wasn&rsquo;t easy. It still is not, but at least
there is a protocol for it.</p><h2 id=what-exists-now-dot>What exists now.</h2><dl><dt>LSPs</dt><dd><a href=https://microsoft.github.io/language-server-protocol/>The protocol</a> that provides IDE like features like
autocompletion, documentation lookup, and jumping to
definition. These things are powerful, and navigating/editing a
large codebase without them is the equivalent of telling your
company &ldquo;I want to waste your money by taking longer to code while
being in the dark as far as knowing what&rsquo;s wrong with the code.&rdquo; I&rsquo;m
very much biased and think they&rsquo;re necessary. They warn you of
errors and provide non-intrusive completion. If the completion is
intrusive, or doesn&rsquo;t warn you properly, you&rsquo;re using the wrong LSP.</dd><dt>DAP</dt><dd><a href=https://microsoft.github.io/debug-adapter-protocol/>DAP</a> is another gift from the world&rsquo;s most beloved
conglomorate. I&rsquo;ll be honest; I don&rsquo;t use it much, but the few times
I&rsquo;ve tried it it has solved my problem(s).</dd><dt>Tree sitter</dt><dd><a href=https://tree-sitter.github.io/tree-sitter/>This</a> was the final nail in the coffin for
IDEs<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Tree sitter is an incremental parser, and it&rsquo;s designed to
be fast. Tree sitter gave a lispy like AST definition of non-lisp
languages to the editor and made parsing a breeze. I&rsquo;ve never
written tree-sitter grammars, but I have messed around with
text-objects and it feels like lisp, because it is lisp.</dd></dl><h2 id=what-i-need>What I need</h2><p>I&rsquo;m going to be more picky. What <em>I</em> consider bare-minimum does not
reflect anyone else&rsquo;s, but to me, these are the bare minimums in 2025.</p><h3 id=what-are-the-bare-minimums>What are the bare minimums?</h3><dl><dt>Tree-sitter-powered syntax highlighting out of the box</dt><dd>I want
correct syntax highlighting, not some regex hack from 2 decades
ago. Emacs <em>barely</em> passes this, but at least major languages have a
<code>*-ts-mode</code>, however this eliminates <a href=https://github.com/microsoft/vscode/issues/50140>VSCode</a>, <a href=https://github.com/vim/vim/issues/12508>Vim</a>, and <a href=https://github.com/lem-project/lem/issues/757>Lem</a>.</dd><dt>LSP support out of the box</dt><dd>While Neovim has an <a href=https://neovim.io/doc/user/lsp.html>lsp client</a>
builtin, I can&rsquo;t randomly open some <code>.rs</code> file and expect <a href=https://rust-analyzer.github.io/>rust
analyzer</a> to show me docs when I <code>K</code>; it requires a little bit of
configuration. Many languages have official LSPs and for those that
don&rsquo;t, there are well-recognized ones, and that should be picked if
it&rsquo;s on the path. This eliminates Neovim, and <a href=https://github.com/kakoune-lsp/kakoune-lsp>Kakoune</a>.</dd><dt>Motion→Action modal editing out of the box</dt><dd>This eliminates Emacs,
though it is still my primary editor since I use <a href=https://github.com/meow-edit/meow>Meow</a>. I personally
do not like Vim&rsquo;s modal editing, so Kakoune, Meow, or Helix are
my first choices.</dd></dl><h3 id=who-meets-the-bare-minimums>Who meets the bare minimums?</h3><dl><dt><a href=https://helix-editor.com/>Helix</a></dt><dd>Helix is my favorite text editor. Helix took its
Motion→Action model <a href=https://docs.helix-editor.com/usage.html#selection-first-editing>from Kakoune</a>, and while Kakoune has a much nicer
defaults, it lacks many features that I consider to be
necessary. Helix is simply the fastest, least buggy, and most
accessible editor I&rsquo;ve ever used. DAP, LSP, and TS are all
implemented for all mainstream and even non-mainstream languages out
of the box.</dd><dt><a href=https://flow-control.dev/>Flow</a></dt><dd>This is fast, but not as stable as Helix. It does have Helix
keybinding emulation. It does have features I need. A +1 goes to
this editor because it&rsquo;s written is Zig, making it much faster to
compile, and it&rsquo;s much easier to <a href=https://zig.guide/build-system/cross-compilation/>cross-compile</a> (I compiled it on
Linux and <code>scp</code> d it to my Windows machine and it just worked).</dd><dt><a href=https://zed.dev/>Zed</a></dt><dd>While this editor is not geared towards power users,
auto-installs LSPs like VSCode instead of picking them up from the
path, and is a pain to install on Windows (I cargo-built it from
source and it took a long time + 10G of dependency junk), it works
and satisfies my basic needs. It&rsquo;s not as fast as the previous 2,
but it does have Helix keybinding emulation to a greater extent than
Flow.</dd></dl><h3 id=a-little-past-the-bare-minimums>A little past the bare minimums</h3><p>There are no perfect editors. The 3 &ldquo;winner&rdquo; options all lack
extensibility. Helix is configured with TOML. Flow and Zed are
configured with JSON.</p><p>My <em>ideal</em> editor would be one that also has:</p><dl><dt>Structured editing</dt><dd>Not just for lisps, but also for general
purpose languages. What some editors do is use TS text-objects, but
I wouldn&rsquo;t mind it another way. My current setup is bad; Helix has
TS text-object <a href=https://github.com/helix-editor/helix/tree/master/runtime/queries>queries</a>, which <a href=https://github.com/meain/evil-textobj-tree-sitter/tree/master/queries>evil-textobj-tree-sitter</a> uses, which I
end up using from <a href=https://github.com/skissue/meow-tree-sitter/tree/main/queries>meow-tree-sitter</a>. I&rsquo;m not a huge fan of
extra-fancy stuff like <a href=https://github.com/mickeynp/combobulate>combobulate</a>, but a basic syntax-aware &ldquo;delete
inside this function&rdquo; or &ldquo;highlight around this argument&rdquo; goes a long way.</dd><dt>Lisp configuration</dt><dd>This is pretty much self-explanatory; Emacs with
Elisp, Lem with CL, Helix with Steel, <a href=https://github.com/Olical/nfnl>Neovim with Fennel</a>, and the
list goes on.</dd></dl><h2 id=the-future>The future?</h2><p>The closest option to an &ldquo;ideal&rdquo; editor would still be Emacs, <strong>if</strong>
you&rsquo;re willing to install some and do some configuration. Neovim is a
close second, but a lot of the default keys would need to be
modified to mimic Helix. Neovim lacks a real GUI (I can&rsquo;t have mixed
pitch fonts in Neovide), and Emacs is unbearably slow (I&rsquo;m on an
8c/16t 5.1Ghz Ryzen with 64G of LPDDR5 RAM, with <a href=https://www.gnu.org/software/emacs/manual/html_node/elisp/Native-Compilation.html>native comp</a> enabled,
and it&rsquo;s still slower than Neovim on a raspberry pi).</p><p>What I <em>hope</em> for the future may or may not match the reality, but here
it goes:</p><ul><li><a href=https://github.com/helix-editor/helix/pull/8675>The Steel PR</a> is finally merged into Helix.</li><li>Having used Guix on a daily basis for a whlie now, I don&rsquo;t expect
<a href=https://guile-emacs.org/>Guile-Emacs</a> to have a decent speed, since Guile <strong>3</strong> is slow, Emacs is
slow, the Emacs elisp interpreter is slow, and the <a href=https://www.gnu.org/software/guile/manual/html_node/Emacs-Lisp.html>Guile elisp
interpreter</a> is slow, but hey, the people crazy enough to work on the
<a href=https://emacsconf.org/2024/talks/guile/>relaunch</a> might figure something out.</li><li>Lem starts to support TS out of the box instead of following the
custom modes like legacy Emacs, and something Meow/<a href=https://github.com/lem-project/lem/issues/1876>Helix</a>-like makes
its way to the default build.</li></ul><p>If you ask &ldquo;Why don&rsquo;t you build a tool instead of waiting?&rdquo; I will
respond with the fact that I have Emacs. It may be slow, buggy,
single-threaded, resource-intensitve, and old, but it&rsquo;s the only
option that satisfies all my requirements, so we march forward.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Not really. Intellij products, Visual Studio, Android Studio, and
especially the vendor-locked XCode are still out there and thriving,
but <em>a lot</em> of language-specific IDEs just became unnecessary when tree
sitter and language server became popular.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><ul class=pa0><li class="list di"><a href=/blog/tags/editors/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Editors</a></li><li class="list di"><a href=/blog/tags/emacs/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Emacs</a></li><li class="list di"><a href=/blog/tags/helix/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Helix</a></li><li class="list di"><a href=/blog/tags/opinion/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Opinion</a></li><li class="list di"><a href=/blog/tags/rant/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Rant</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://arian-d.github.io/blog/>&copy; Arian's blog 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>